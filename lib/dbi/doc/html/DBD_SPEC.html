<?xml version="1.0" ?>
<!DOCTYPE html 
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>DBD Specification Version 0.1 (Draft)</title>
<link href="http://www.ruby-projects.org/dbi/rubyStyle.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1><a name="label:0" id="label:0">DBD Specification Version 0.2 (Draft)</a></h1><!-- RDLabel: "DBD Specification Version 0.2 (Draft)" -->
<p>by Michael Neumann (neumann@s-direknet.de)</p>
<pre>$Id: DBD_SPEC.html,v 1.17 2001/11/14 14:08:16 michael Exp $</pre>
<h2><a name="label:1" id="label:1">DBD Directory Layout</a></h2><!-- RDLabel: "DBD Directory Layout" -->
<p>The directory layout is the following:</p>
<pre>DBD/
DBD/Driver1
DBD/Driver1/Driver1.rb
DBD/Driver1/helper.rb
.
.

DBD/Driver2
.
.
.</pre>
<p>Where "Driver1" and "Driver2" are the names of DBD driver.
For example if you have two drivers installed, "Oracle" and 
"Sybase" it would look like:</p>
<pre>DBD/
DBD/Oracle
DBD/Oracle/Oracle.rb         # &lt;== this is the main driver
DBD/Oracle/oracle.so         # &lt;== is used by Oracle.rb

DBD/Sybase/Sybase.so         # &lt;== this is the main driver
                             # has no helper files</pre>
<p>When DBI loads a DBD driver it search all "DBD" directories in Ruby's
LOAD_PATH ($:).</p>
<p>Database dependent functions, that should be callable with DBI::func, must
use the prefix "__" before their method names, to prevent nameclashes with 
further versions of Ruby/DBI!</p>
<h2><a name="label:2" id="label:2">Driver Name</a></h2><!-- RDLabel: "Driver Name" -->
<p>The DBD driver is simply named after the Database, e.g. Oracle, DB2 etc.
The suffix will normally be ".rb" but can be any other valid suffix, 
which Ruby is possible to load, e.g. ".so", ".sl" or ".dll", and depends
for non-Ruby DBD driver on the underlying operating system.
When I refer to the driver name, then I speak of the filename without
the suffix, e.g. Oracle or DB2.</p>
<p>The name specified in the DSN <a name="footmark:1" id="footmark:1" href="#foottext:1"><sup><small>*1</small></sup></a> 
must be the same as the driver name. </p>
<h2><a name="label:3" id="label:3">Classes provided by a DBD</a></h2><!-- RDLabel: "Classes provided by a DBD" -->
<p>A DBD driver has to provide three classes in the namespace
<code>DBI::DBD::</code><em>DriverName</em> where <em>DriverName</em> is the name of the 
driver, e.g. Oracle or DB2.</p>
<p>The three classes must be named <code>Driver</code>, <code>Database</code> and <code>Statement</code>.</p>
<h2><a name="label:4" id="label:4">Class Driver</a></h2><!-- RDLabel: "Class Driver" -->
<p>This class must inherit from <code>DBI::BaseDriver</code>.</p>
<h3><a name="label:5" id="label:5">Methods which must be provided by <code>Driver</code></a></h3><!-- RDLabel: "Methods which must be provided by Driver" -->
<dl>
<dt><a name="label:6" id="label:6"><code>connect( <var>dbname</var>, <var>user</var>, <var>auth</var>, <var>attr</var> )</code></a></dt><!-- RDLabel: "connect" -->
<dd>
<p>Connect to a database and return a newly created <code>Database</code> object.</p></dd>
</dl>
<h3><a name="label:7" id="label:7">Optional methods which can be specified by <code>Driver</code></a></h3><!-- RDLabel: "Optional methods which can be specified by Driver" -->
<dl>
<dt><a name="label:8" id="label:8"><code>default_user</code></a></dt><!-- RDLabel: "default_user" -->
<dd>
<p>Return an array of the form <code>['username', 'password']</code> which represent
the default user when no user and password was specified.</p>
<p>Defaults to <code>['', '']</code> if not implemented.</p></dd>
<dt><a name="label:9" id="label:9"><code>default_attributes</code></a></dt><!-- RDLabel: "default_attributes" -->
<dd>
<p>Return a <code>Hash</code> containing the default attributes which are used
in <code>connect</code> additional to the ones the user specify.</p>
<p>Defaults to <code>{}</code> (empty hash) if not implemented.   </p></dd>
<dt><a name="label:10" id="label:10"><code>data_sources</code></a></dt><!-- RDLabel: "data_sources" -->
<dd>
<p>Return an array of all valid DSN this driver can access.</p>
<p>Defaults to <code>[]</code> (empty array) if not implemented.     </p></dd>
<dt><a name="label:11" id="label:11"><code>disconnect_all</code></a></dt><!-- RDLabel: "disconnect_all" -->
<dd>
<p>Disconnect all connections made with this driver.</p>
<p>Defaults to raise a NotImplementedError.</p></dd>
</dl>
<h2><a name="label:12" id="label:12">Class Database</a></h2><!-- RDLabel: "Class Database" -->
<p>This class must inherit from <code>DBI::BaseDatabase</code>.</p>
<h3><a name="label:13" id="label:13">Methods which must be provided by <code>Database</code></a></h3><!-- RDLabel: "Methods which must be provided by Database" -->
<dl>
<dt><a name="label:14" id="label:14"><code>disconnect</code></a></dt><!-- RDLabel: "disconnect" -->
<dd>
<p>Disconnect from database.
But before you have to rollback all outstanding transactions, so 
all changes not yet commited get lost.</p></dd>
<dt><a name="label:15" id="label:15"><code>prepare( <var>statement</var> )</code></a></dt><!-- RDLabel: "prepare" -->
<dd>
<p>Prepare the SQL <em>statement</em> and return an object of class <code>Statement</code>.</p></dd>
<dt><a name="label:16" id="label:16"><code>ping</code></a></dt><!-- RDLabel: "ping" -->
<dd>
<p>Ping the database, and check if the connection is alive.
This can be implemented by executing a SQL statement like
"SELECT 1 FROM DUAL" for Oracle database, or for other databases
this should be query on a table which normally always exists.</p>
<p>Return <code>true</code> if the connection is alive, otherwise <code>false</code>.</p></dd>
</dl>
<h3><a name="label:17" id="label:17">Optional methods which can be specified by <code>Database</code></a></h3><!-- RDLabel: "Optional methods which can be specified by Database" -->
<dl>
<dt><a name="label:18" id="label:18"><code>commit</code></a><!-- RDLabel: "commit" -->
<dt><a name="label:19" id="label:19"><code>rollback</code></a></dt><!-- RDLabel: "rollback" -->
<dd>
<p>Commit or roll back the current transaction.</p>
<p>Defauls to raise a NotSupportedError, so if the database do not implement 
transactions (mSQL, mySQL, CSV) do not overwrite this method.</p></dd>
<dt><a name="label:20" id="label:20"><code>tables</code></a></dt><!-- RDLabel: "tables" -->
<dd>
<p>Return an Array of all tables and views. </p>
<p>Defaults to return the empty Array [].</p></dd>
<dt><a name="label:21" id="label:21"><code>columns( <var>table</var> )</code></a></dt><!-- RDLabel: "columns" -->
<dd>
<p>Return more information about the columns of table <em>table</em>. 
Return an Array of Hashes, like Statement#column_info do.</p>
<p>Defaults to return an empty Array [].</p></dd>
<dt><a name="label:22" id="label:22"><code>execute( <var>statement</var>, *<var>bindvars</var> )</code></a></dt><!-- RDLabel: "execute" -->
<dd>
<p>Immediate execution (without preparation) of SQL <em>statement</em>
with binding of placeholders to values given in <em>bindvars</em> before.</p>
<p>Return a <code>Statement</code> object.</p>
<p>Defaults to the call sequence of Database#prepare(), Statement#bind_params() and 
Statement#execute().</p></dd>
<dt><a name="label:23" id="label:23"><code>do( <var>statement</var>, *<var>bindvars</var> )</code></a></dt><!-- RDLabel: "do" -->
<dd>
<p>Execution of SQL <em>statement</em> with binding of placeholders to values given
in <em>bindvars</em> before, but without returning a <code>Statement</code> object.
So this is used for 'INSERT', 'UPDATE', 'DELETE' as well as for DCL, which
do not return a result-set.</p>
<p>Return the RPC (Row Processed Count) or <code>nil</code> if no RPC is available.</p>
<p>Defaults to Database#execute() and Statement#rows() followed by Statement#finish(). </p></dd>
<dt><a name="label:24" id="label:24"><code>quote( <var>value</var> )</code></a></dt><!-- RDLabel: "quote" -->
<dd>
<p>Quote the given value <em>value</em> database specific and return the result.</p>
<p>NOTE: This method is not really useful, because of Statement#bind_param. </p></dd>
<dt><a name="label:25" id="label:25"><code>[ <var>attr</var> ]</code></a></dt><!-- RDLabel: "[]" -->
<dd>
<p>Return value of attribute <em>attr</em>.</p>
<p>Defauls to return the value of <code>@attr[attr]</code>.</p></dd>
<dt><a name="label:26" id="label:26"><code>[<var>attr</var>] = <var>value</var></code></a></dt><!-- RDLabel: "[]=" -->
<dd>
<p>Set value of attribute <em>attr</em> to <em>value</em>.
An attribute is e.g. "AutoCommit".
Raise an NotSupportedError, if the database do not support an attribute.</p>
<p>The default implementation is to raise a NotSupportedError.</p></dd>
</dl>
<h2><a name="label:27" id="label:27">Class Statement</a></h2><!-- RDLabel: "Class Statement" -->
<p>This class must inherit from <code>DBI::BaseStatement</code>.</p>
<h3><a name="label:28" id="label:28">Methods which must be provided by <code>Statement</code></a></h3><!-- RDLabel: "Methods which must be provided by Statement" -->
<dl>
<dt><a name="label:29" id="label:29"><code>bind_param( <var>param</var>, <var>value</var>, <var>attribs</var> )</code></a></dt><!-- RDLabel: "bind_param" -->
<dd>
<p>Bind <var>param</var> which is either a <code>String</code> which is then the name of the 
placeholder used in the SQL statement (e.g. Oracle: "SELECT * FROM EMP WHERE ENAME = :ename") 
or it is a <code>Fixnum</code> which is then the number of the placeholder where counting starts at 1.</p>
<p><var>value</var> is the value which is bound to the placeholder.
If <var>value</var> is a <code>String</code>, then the default SQL type is <code>VARCHAR</code> or <code>CHAR</code>.
If <var>value</var> is a <code>Fixnum</code> or <code>Bignum</code>, the default SQL type is <code>INT</code>.
If <var>value</var> is a <code>Float</code>, the default SQL type is <code>FLOAT</code>.</p>
<p><em>attribs</em> is not yet used in this version but could be a hash containing more information
like parameter type etc.</p></dd>
<dt><a name="label:30" id="label:30"><code>execute</code></a></dt><!-- RDLabel: "execute" -->
<dd>
<p>Execute the statement.</p></dd>
<dt><a name="label:31" id="label:31"><code>finish</code></a></dt><!-- RDLabel: "finish" -->
<dd>
<p>Free all the resources for the statement.
After calling <code>finish</code> no other operation on this
statement is valid.</p></dd>
<dt><a name="label:32" id="label:32"><code>fetch</code></a></dt><!-- RDLabel: "fetch" -->
<dd>
<p>Fetch the current row.
Return a <code>Array</code> containing all column-data or <code>nil</code> if
the last column has been read.</p>
<p>Note: This method should return not a newly created object on each call, 
instead you should return one and the same Array object but with 
changed data. </p></dd>
<dt><a name="label:33" id="label:33"><code>column_info</code></a></dt><!-- RDLabel: "column_info" -->
<dd>
<p>Return an <code>Array</code> of <code>Hash</code>'s, one for each column.
Each <code>Hash</code> object must have at least one key 'name' which 
value is the name of that column.
Further possible values are 'sql_type' (integer, e.g. DBI::SQL_INT), 
'type_name' (string), 'precision' (= column size), 'scale' (= decimal digits),
'default', 'nullable', 'indexed', 'primary' and 'unique'.</p></dd>
<dt><a name="label:34" id="label:34"><code>rows</code></a></dt><!-- RDLabel: "rows" -->
<dd>
<p>Return the RPC (Row Processed Count) of the last executed statement, or
<code>nil</code> if no such exist.</p></dd>
</dl>
<h3><a name="label:35" id="label:35">Optional methods which can be specified by <code>Statement</code></a></h3><!-- RDLabel: "Optional methods which can be specified by Statement" -->
<dl>
<dt><a name="label:36" id="label:36"><code>bind_params( *<var>bindvars</var> )</code></a></dt><!-- RDLabel: "bind_params" -->
<dd>
<p>Binds the placeholders in the statement to the values of <var>bindvars</var>.</p>
<p>Defaults to calling <a href="#label:29">bind_param</a> for each value, with <em>param</em> starting
from 1 increasingly.</p></dd>
<dt><a name="label:37" id="label:37"><code>cancel</code></a></dt><!-- RDLabel: "cancel" -->
<dd>
<p>Free any result set resources which were made after a call to <code>execute</code>.
After calling this method, a call to one of the <em>fetch</em> methods is no more valid.</p>
<p>Defaults to do nothing.</p></dd>
<dt><a name="label:38" id="label:38"><code>fetch_scroll( <var>direction</var>, <var>offset</var> )</code></a></dt><!-- RDLabel: "fetch_scroll" -->
<dd>
<p><em>direction</em> is one of the following constants:</p>
<ul>
<li>SQL_FETCH_NEXT</li>
<li>SQL_FETCH_PRIOR</li>
<li>SQL_FETCH_FIRST</li>
<li>SQL_FETCH_LAST</li>
<li>SQL_FETCH_ABSOLUTE</li>
<li>SQL_FETCH_RELATIVE</li>
</ul>
<p><em>offset</em> is a positive or negativ number (only when SQL_FETCH_RELATIVE is used).</p>
<p>By default only SQL_FETCH_NEXT, SQL_FETCH_LAST, SQL_FETCH_RELATIVE (if positive) are
implemented, otherwise it raises NotSupportedError.</p>
<p>Note: This method should return not a newly created object on each call, 
instead you should return one and the same Array object but with 
changed data. </p></dd>
<dt><a name="label:39" id="label:39"><code>fetch_many( <var>cnt</var> )</code></a></dt><!-- RDLabel: "fetch_many" -->
<dd>
<p>Return an <code>Array</code> of the next <em>cnt</em> rows, where a row is itself an <code>Array</code>.</p>
<p>Note: Unlike <code>fetch</code>, this method should return a new Array object.</p>
<p>If there are no more <em>cnt</em> rows available return the rest.
Return <code>nil</code> if no rows are available.</p>
<p>Defaults to multiple calls to <code>fetch</code>.</p></dd>
<dt><a name="label:40" id="label:40"><code>fetch_all</code></a></dt><!-- RDLabel: "fetch_all" -->
<dd>
<p>Return an <code>Array</code> of all rows which have not yet been fetched, where a row is 
itself an <code>Array</code> (see Statement#fetch_many).</p>
<p>Note: Unlike <code>fetch</code>, this method should return a new Array object.</p>
<p>Return <code>nil</code> if no rows are available.</p>
<p>Defaults to multiple calls to <code>fetch</code>.</p></dd>
</dl>
<hr />
<p>
<a name="foottext:1" id="foottext:1" href="footmark:1"><sup><small>*1</small></sup></a><small>Data Source Name, e.g. "dbi:Oracle:oracle.neumann"</small><br />
</p>
</body>
</html>
